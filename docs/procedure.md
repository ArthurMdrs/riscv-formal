
riscv-formal Verification Procedure
===================================

The following formal test are performed to verify ISA compliance of RISC-V processors with `riscv-formal`. Depending on aspects like the strength of safety properties present in the core, the overall complexity of the core, and the verification requirements for the given application, the following tests might be set up as bounded model checks or as unbounded verification tasks.

For most cores the easiest approach is to create a wrapper HDL module and a `checks.cfg` file and
use the `genchecks.py` scripts to create the formal checks.  See
[cores/picorv32/](../cores/picorv32/) for an example implementation.  The checks generated by
`genchecks.py` are bounded model checks which use sby for verification.

Configuring Check Generation
----------------------------

A config file with extension `.cfg` is used to configure the `genchecks.py` script.  By default, the
name of this config file is expected to be `checks`.  Calling `genchecks.py` with an argument will
instead use the provided name.  For example, `python3 ../../checks/genchecks.py tests` will load
config settings from a file named `tests.cfg`.  Note that the script will generate a folder with the
same config name in the directory it is run.

It is expected for `genchecks.py` to be called from a subdirectory of the `cores` folder, such that
the script is called as `../../checks/genchecks.py`, and the subdirectory is the name of the core.
This core name will be used for naming certain intermediary files, but is otherwise arbitrary and
does not need to match anything else.

The config file consists of a number of sections, with each section starting with the name of the
section in square brackets.  Some of these sections are shared between tests, and some are used only
for specific formal checks.  The shared sections will be covered here, while check specific details
will be covered in the relevant section below.

Comments can be included in the config file by prefixing a line with a `#` character.

#### `[options]`

This section primarily contains options which describe the core under test.  Possible options are
listed below, along with their expected value.  For options with no expected value, simply including
the option enables the specified effect.

| Option   | Value   | Description |
| -------- | ------- | ----------- |
| isa      | String  | ISA extensions, e.g. `RV64IMAFD`, or `rv32i`.  Note that X and Z extensions are not currently supported and should be removed from the string. |
| nret     | Integer | The number of channels for the RVFI port.  Defaults to 1. |
| blackbox | None    | Signifies register file and ALU should be black-boxed. |
| solver   | String  | Name of solver, defaults to `boolector`. |
| dumpsmt2 | None    | Passed to `smtbmc` engine to output SMT2 trace. |
| abspath  | None    | Generated makefile will use absolute path of generated files. |
| mode     | String  | Solver mode, currently supports either `bmc` or `prove`, and defaults to `bmc`. |

#### `[depth]`

This section provides the execution depth to be used by the solver for each test.  The name of the
check is listed, followed by one or more integers separated by a space.  For formal checks that
expect multiple values to be provided here, the meaning of each will be defined in the relevant
section.

For cores with multiple channels, the channel number can be used in the name of the check by
appending `_ch#`.  Note that a more specific name will be used over a less specific name.  For
example, if `insn <depth0>` and `insn_ch1 <depth1>` are both listed, `insn` tests on channel 1 will
use `depth1`, while all other channels will use `depth0`.

If a formal check does not have a corresponding depth listed, it will not be generated.  For
example, providing `reg_ch2 <values>` but not `reg <values>` will run the `reg` check *only* on
channel 2.

#### `[groups]`

This section defines a list of group names which are prepended to all check names which can then be
used for grouping multiple checks together.  These groups can then be used for testing with multiple
depth values.  Each group must be separated by whitespace.

As an example, if groups `a` and `b` are listed with depth settings of `a_insn <x>`, 
`b_insn_bne <y>`, then all instructions will be tested with depth `x`, and the `bne` instruction
will be tested to both depths `x` and `y`.

#### `[sort]`

If this section is included, any listed checks will be run in the order they appear in this list,
and will be run *before* any un-listed checks.  Each item should be placed on its own line.  When
multiple checks match the same ordering, alphabetical order will be used.  

Note that regex is used to search for a match of the *full* check name, including group and channel.
This can be used to, for example, list all checks on channel 2 before any others by adding `.*?_ch2`
as the first item.  If the user is unfamiliar with regex, simply providing the names of checks
verbatim will also work.

Note that this sorting also determines the order in which checks are generated in the makefile.  The
order in which tests are started should be maintained by Make, however if parallelism is enabled
then there is no guarantee that tests will *complete* in this order.

#### `[filter-checks]`

Specific checks can be enabled or disabled by adding them to this section prefixed with either a `+`
or `-` and a space.  As with `[sort]` above, regex is used for matching against each line.  Note
that the *first* match returns.  For example, if `+ insn_(mul|div)_ch1` is listed before 
`- insn_.*_ch1`, then the `mul` and `div` instructions will be enabled for testing on channel 1, 
while all other instructions are disabled.

#### `[assume]`

Each line of this section provides a two value tuple.  The first value is the regex pattern used to
match the current check name, while the second value is code to be included in the file
`assume_stmts.vh`.  If the first value begins with a `!`, the code is used for all checks that *do
not* match the pattern, otherwise the code is used for all checks that *do* match.  This file is
included verbatim at the end of the `rvfi_testbench` module in
[checks/rvfi_testbench.sv](../checks/rvfi_testbench.sv), and so should be valid System Verilog code.

### Verbatim sections

A number of sections are included in the sby script essentially as-is.  These sections are formatted
with a few keyword substitutions.  If using these substitutions, the keywords should be prepended
and appended with a `@` symbol, e.g. `@basedir@/cores/@core@/wrapper.sv` is using the `basedir` and
`core` keywords to define the path.

Possible keywords include:

- basedir: the root directory of riscv-formal
- core: the name of the directory from which the script is executed
- ilang_file: filename of intermediary output
- channel: the current rvfi channel
- check: the current check, e.g. `csrc`
- checkch: the full name of the current check, e.g. `a_csrc_misa_ch0`

#### `[script-defines]`

This section is included at the *start* of the sby `[script]` section.  Check specific code can also
be included as `[script-defines <check>]`, where `<check>` is the current check.

#### `[verilog-files]` and `[vhdl-files]`

These sections list all of the core source files which should be included in testing.  All verilog files will be listed after `read -sv `, while all vhdl files will be listed after `read -vhdl`.

#### `[script-sources]`

This section can be used to add any other source files which do not fit under `-sv` or `-vhdl`, and is included *before* the `prep` command.

#### `[script-link]`

This section is included *after* the `prep` command and *before* `chformal`.

#### `[defines]`

This section is included as part of `[file defines.sv]`.  Check specific code can also be included
as `[defines <check>]`, where `<check>` is the current check.

Standard Checks
---------------

The following checks are managed by `genchecks.py` and can be implemented using the standard RVFI wrapper interface.

### Instruction Checks

The majority of formal checks needed to verify a core with riscv-formal are instruction checks (one per RVFI channel and RISC-V instruction supported by the core).

Instruction checks test if the instruction (`rvfi_insn`) matches the state transistion described by the other RVFI signals.

### PC Checks

There are two PC checks: `pc_fwd` and `pc_bwd`. Both of them are run for each RVFI channel.

The `pc_fwd` check assumes that the core retires an instruction at the end of the bounded model check, and that the previous instruction in the program (`rvfi_order-1`) was retired earlier. It then tests if `rvfi_pc_wdata` of the previous instruction matches `rvfi_pc_rdata` of the next instruction.

`pc_bwd` is like `pc_fwd` but for pairs of instructions that have been executed out of order: The check assumes that the core retires an instruction at the end of the bounded model check, and that the next instruction in the program (`rvfi_order+1`) was retired earlier. It then tests if `rvfi_pc_wdata` of the previous instruction matches `rvfi_pc_rdata` of the next instruction.

#### `[depth]` section

Expects two values: first is the number of cycles to reset for; second is the execution depth.

### Register Checks

This checks if writes to and reads from the register file are consistent with each other, i.e. if the value written to a register matches the value read from the register file by a later instructions.

This check assumes that the last instruction at the end of the bounded model check, reads a register. It then checks that the value read is consistent with the matching write to the same register by an earlier instruction.

#### `[depth]` section

Expects two values: first is the number of cycles to reset for; second is the execution depth.

### Causality

The core may retire instructions out-of-order as long as causality is preserved. (This means a register write must be retired before the register reads that depend on it.) This check tests if the
instruction stream is causal with respect to registers.

#### `[depth]` section

Expects two values: first is the number of cycles to reset for; second is the execution depth.

### Liveness

This check makes sure that the core never freezes (unless an instruction with `rvfi_halt` asserted is retired): This check assumes that an instruction is retired at a configurable trigger point in the middle of the bounded model check. It then checks that the next instruction (`rvfi_order+1`) is also retired at some point during the span of the bounded model check.

It might be neccessary to add some bounded fairness constraints to the design for this check to succeed.

#### `[depth]` section

Expects three values: first is the number of cycles to reset for; second is the trigger depth; and
third is the execution depth.

### Uniqueness

This check makes sure that no two instructions with the same `rvfi_order` are retired by the core.

#### `[depth]` section

Expects three values: first is the number of cycles to reset for; second is the trigger depth; and
third is the execution depth.

### Cover

A formal check using `cover()` SystemVerilog statements for various interesting RVFI events or
sequences of events. The purpose of this formal check is to collect some data about the required
bounds to reach certain states to set the bounds for the other bounded model checks. This check can
also be used for creating witness traces, for example to examine the conditions under which a
specific CSR bit goes high.

#### `[depth]` section

Expects two values: first is the number of cycles to reset for; second is the execution depth.

#### `[cover]` section

All code in this section is included verbatim in the file `cover_stmts.vh`, which is included
verbatim in [checks/rvfi_cover_check.sv](../checks/rvfi_cover_check.sv), and so should be valid
System Verilog code.


Other Checks
------------

The following checks are not yet managed by `genchecks.py` and can not be implemented using the standard RVFI wrapper interface. Some of them may be integrated with `genchecks.py` in the future.

### Instruction Memcheck

This check adds a memory abstraction that only emulates a single word of memory (at an unconstrained address). This memory word is read-only and has an unconstrained value. The check makes sure that instructions fetched from this memory word are handled correctly and that the data from that memory word makes its way into `rvfi_insn` unharmed.

See `imemcheck.sv` in [cores/picorv32/](../cores/picorv32/) for an example implementation.

### Data Memcheck

This check adds a memory abstraction that only emulates a single word of memory (at an unconstrained address). The memory word is read/write. The check tests if writes to and reads from the memory location (as reported via RVFI) are consistent.

See `dmemcheck.sv` in [cores/picorv32/](../cores/picorv32/) for one possible implementation of this test.

### Checking for equivalence of core with and without RVFI

An equivalence check of the core with and without RVFI (with respect to the non-RVFI outputs) is performed. This proves that the verification results for the core with enabled RVFI also prove that the (non-RVFI) production core is correct without extra burden on the core designer to isolate the RVFI implementation from the rest of the core.

See `equiv.sh` in [cores/picorv32/](../cores/picorv32/) for an example implementation.

### Complete

An additional check to make sure the core can not (without trap) retire any instructions that are not covered by the riscv-formal instruction checks.

See `complete.sv` in [cores/picorv32/](../cores/picorv32/) for one possible implementation of this test.

### Verification of riscv-formal models against spike models

The checks in [tests/spike/](../tests/spike/) use the Yosys SimpleC back-end and CBMC to check the `riscv-formal` models and the C instruction models from spike for equivalence.

